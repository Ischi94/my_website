---
title: "Rethinking Chapter 5"
author: "Gregor Mathes"
date: "2021-01-13"
slug: Rethinking Chapter 5
categories: []
tags: [Rethinking, Bayes, Statistics]
subtitle: ''
summary: 'This is the fourth part of a series where I work through the practice questions of the second edition of Richard McElreaths Statistical Rethinking'
authors: [Gregor Mathes]
lastmod: '2021-01-13T12:07:04+02:00'
featured: no
projects: [Rethinking]
output:
  blogdown::html_page:
    toc: true
    toc_depth: 1
    number_sections: true
    fig_width: 6
---

<script src="/rmarkdown-libs/header-attrs/header-attrs.js"></script>

<div id="TOC">
<ul>
<li><a href="#introduction"><span class="toc-section-number">1</span> Introduction</a></li>
<li><a href="#easy-practices"><span class="toc-section-number">2</span> Easy practices</a></li>
<li><a href="#medium-practices"><span class="toc-section-number">3</span> Medium practices</a></li>
<li><a href="#hard-practices-online"><span class="toc-section-number">4</span> Hard practices online</a></li>
<li><a href="#hard-practices-print"><span class="toc-section-number">5</span> Hard practices print</a></li>
</ul>
</div>

<div id="introduction" class="section level1" number="1">
<h1><span class="header-section-number">1</span> Introduction</h1>
<p>This is the fourth part of a series where I work through the practice questions of the second edition of Richard McElreaths <a href="https://xcelab.net/rm/statistical-rethinking/">Statistical Rethinking</a>. Each post covers a new chapter and you can see the posts on previous chapters <a href="https://gregor-mathes.netlify.app/tags/rethinking/">here</a>.<br />
The third part of the series will cover chapter 5, which corresponds to the first part of week 3 of the lectures and homework (which you can find <a href="https://github.com/rmcelreath/stat_rethinking_2020">here</a>). The homework of week 3 will be covered in the next part about chapter 6.<br />
From now on, I will set a given colour scheme for each chapter. This is mostly for me to see which colours play nice together, but additionally will make the appearance of the blog posts more consistent.<br />
The colours for this blog post are:</p>
<pre class="r"><code>red &lt;- &quot;#B74F35&quot;
yellow &lt;- &quot;#FFB81C&quot;
blue &lt;- &quot;#0E345E&quot;
lightblue &lt;- &quot;#85ACA9&quot;</code></pre>
<div class="figure">
<img src="/post/chapter5_files/figure-html/colours%20plot-1.png" alt="*Colour scheme used throughout each plot for this chapter.*" width="672" />
<p class="caption">
(#fig:colours plot)<em>Colour scheme used throughout each plot for this chapter.</em>
</p>
</div>
<p>I have joined a Bayes study group established and managed by the brilliant <a href="https://www.erikkusch.com/">Erik Kusch</a>. Erik has given us access to an online version of the second edition of <em>Statistical Rethinking</em> and I have noticed that some exercises in this online version differ from the print version. I have indicated from which version a particular exercise is from where relevant, but will work through both versions if feasible.</p>
</div>
<div id="easy-practices" class="section level1" number="2">
<h1><span class="header-section-number">2</span> Easy practices</h1>
<div id="question-5e1" class="section level2" number="2.1">
<h2><span class="header-section-number">2.1</span> Question 5E1</h2>
<p><strong>Which of the linear models below are multiple linear regressions?</strong></p>
<ol style="list-style-type: decimal">
<li><span class="math inline">\(\mu_i = \alpha + \beta_xi\)</span></li>
<li><span class="math inline">\(\mu_i = \beta_x x_i + \beta_z z_i\)</span></li>
<li><span class="math inline">\(\mu_i = \alpha + \beta(x_i – z_i)\)</span></li>
<li><span class="math inline">\(\mu_i = \alpha + \beta_x x_i + \beta_z z_i\)</span></li>
</ol>
<p><code>1.</code> contains only one predictor variable (<span class="math inline">\(\beta_xi\)</span>) and is therefore a bivariate linear regression.<br />
<code>2.</code> has two predictor variables and is a multiple linear regression without an intercept (<span class="math inline">\(\alpha\)</span>).<br />
<code>3.</code> the right side can written as <span class="math inline">\(\alpha + \beta x_i - \beta z_i\)</span> which looks like a weird multiple regression with negatively correlated slopes for each predictor.<br />
<code>4.</code> is a perfectly looking multiple linear regression.</p>
</div>
<div id="question-5e2" class="section level2" number="2.2">
<h2><span class="header-section-number">2.2</span> Question 5E2</h2>
<p><strong>Write down a multiple regression to evaluate the claim: Animal diversity is linearly related to latitude, but only after controlling for plant diversity. You just need to write down the model definition.</strong></p>
<p>Let <span class="math inline">\(\mu_i\)</span> be the mean animal diversity, <strong>L</strong> latitude, and <strong>P</strong> plant diversity,<br />
then <span class="math inline">\(\mu_i = \alpha + \beta_L L_i + \beta_P P_i\)</span>.</p>
</div>
<div id="question-5e3" class="section level2" number="2.3">
<h2><span class="header-section-number">2.3</span> Question 5E3</h2>
<p><strong>Write down a multiple regression to evaluate the claim: Neither the amount of funding nor size of laboratory is by itself a good predictor of time to PhD degree; but together these variables are both positively associated with time to degree. Write down the model definition and indicate which side of zero each slope parameter should be on.</strong></p>
<p>Let <span class="math inline">\(\mu_i\)</span> be the time to PhD, <strong>F</strong> the amount of funding, and <strong>S</strong> the size of laboratory,<br />
then <span class="math inline">\(\mu_i = \alpha + \beta_F F_i + \beta_S S_i\)</span>,<br />
where both <span class="math inline">\(beta_F\)</span> &amp; <span class="math inline">\(beta_S &gt; 0\)</span>.</p>
</div>
<div id="question-5e4" class="section level2" number="2.4">
<h2><span class="header-section-number">2.4</span> Question 5E4</h2>
<p><strong>Suppose you have a single categorical predictor with 4 levels (unique values), labeled A, B, C, and D. Let Ai be an indicator variable that is 1 where case i is in category A. Also suppose Bi, Ci, and Di for the other categories. Now which of the following linear models are inferentially equivalent ways to include the categorical variable in a regression? Models are inferentially equivalent when it’s possible to compute one posterior distribution from the posterior distribution of another model.</strong></p>
<ol style="list-style-type: decimal">
<li><span class="math inline">\(\mu_i = \alpha + \beta_A A_i + \beta_B B_i + \beta_D D_i\)</span></li>
<li><span class="math inline">\(\mu_i = \alpha + \beta_A A_i + \beta_B B_i + \beta_C C_i + \beta_D D_i\)</span></li>
<li><span class="math inline">\(\mu_i = \alpha + \beta_B B_i + \beta_C C_i + \beta_D D_i\)</span></li>
<li><span class="math inline">\(\mu_i = \alpha_A A_i + \alpha_B B_i + \alpha_C C_i + \alpha_D D_i\)</span></li>
<li><span class="math inline">\(\mu_i = \alpha_A (1 – B_i – C_i – D_i) + \alpha_B B_i + \alpha_C C_i + \alpha_D D_i\)</span></li>
</ol>
<p>This question was a bit to complicated for me and I just copied over the answer from <a href="https://jmgirard.com/statistical-rethinking-ch5/">Jeffrey Girard</a>:</p>
<p><em>The first model includes a single intercept (for category C) and slopes for A, B, and D. The second model is non-identifiable because it includes a slope for all possible categories (page 156). The third model includes a single intercept (for category A) and slopes for B, C, and D. The fourth model uses the unique index approach to provide a separate intercept for each category (and no slopes). The fifth model uses the reparameterized approach on pages 154 and 155 to multiply the intercept for category A times 1 when in category A and times 0 otherwise. Models 1, 3, 4, and 5 are inferentially equivalent because they each allow the computation of each other’s posterior distribution (e.g., each category’s intercept and difference from each other category).</em></p>
</div>
</div>
<div id="medium-practices" class="section level1" number="3">
<h1><span class="header-section-number">3</span> Medium practices</h1>
<div id="question-5m1" class="section level2" number="3.1">
<h2><span class="header-section-number">3.1</span> Question 5M1</h2>
<p><strong>Invent your own example of a spurious correlation. An outcome variable should be correlated with both predictor variables. But when both predictors are entered in the same model, the correlation between the outcome and one of the predictors should mostly vanish (or at least be greatly reduced).</strong></p>
<p>Let’s directly enter each simulation in a data frame. For each variable, we sample 100 values from a normal distribution. The outcome variable is only related to the first predictor, but the second predictor is as well dependent on the first predictor. To make the selections of priors easier, I transform each variable into z-scores using the <code>scale()</code>.</p>
<pre class="r"><code>N &lt;- 100
dfr &lt;- tibble(pred_1 = rnorm(N), 
       pred_2 = rnorm(N, -pred_1), 
       out_var = rnorm(N, pred_1)) %&gt;% 
  mutate(across(everything(), scale))</code></pre>
<p>Now let’s see how the outcome is related to the first predictor within a linear regression using quadratic approximation:<br />
Notice that I used priors that are not flat but instead are within a realistic realm. <span class="math inline">\(\alpha\)</span> must be pretty close to 0 when we standardise the outcome and the predictor. The prior on the slope <span class="math inline">\(\beta\)</span> is a bit more wider but still only captures realistic relationships as seen in prior predictive simulations throughout the chapter.</p>
<pre class="r"><code>m1 &lt;- alist(out_var ~ dnorm(mu, sigma),
      mu &lt;- a + B1*pred_1,
      a ~ dnorm(0, 0.2), 
      B1 ~ dnorm(0, 0.5),
      sigma ~ dexp(1)) %&gt;% 
  quap(., data = dfr) %&gt;% 
  precis() %&gt;% 
  as_tibble(rownames = &quot;estimate&quot;)</code></pre>
<p>Let’s do the same for the second predictor and the outcome, using similar priors. This is the predictor which is not causally related to the outcome, but still shows a correlation.</p>
<pre class="r"><code>m2 &lt;- alist(out_var ~ dnorm(mu, sigma),
            mu &lt;- a + B2*pred_2,
            a ~ dnorm(0, 0.2), 
            B2 ~ dnorm(0, 0.5),
            sigma ~ dexp(1)) %&gt;% 
  quap(., data = dfr) %&gt;% 
  precis() %&gt;% 
  as_tibble(rownames = &quot;estimate&quot;)</code></pre>
<p>And finally putting both predictors in a multiple linear regression, which should showcase the true relationships.</p>
<pre class="r"><code>m3 &lt;- alist(out_var ~ dnorm(mu, sigma),
            mu &lt;- a + B1*pred_1 + B2*pred_2,
            a ~ dnorm(0, 0.2),
            B1 ~ dnorm(0, 0.5),
            B2 ~ dnorm(0, 0.5),
            sigma ~ dexp(1)) %&gt;% 
  quap(., data = dfr) %&gt;% 
  precis() %&gt;% 
  as_tibble(rownames = &quot;estimate&quot;)</code></pre>
<p>Now we can add the <span class="math inline">\(\beta\)</span> estimates of each model, which capture the relationship between each predictor and the outcome, to a dataframe and plot it.</p>
<pre class="r"><code>full_join(m1, m2) %&gt;% 
  full_join(m3) %&gt;% 
  add_column(model = rep(paste(&quot;Model&quot;, 1:3), c(3, 3, 4))) %&gt;% 
  filter(estimate %in% c(&quot;B1&quot;, &quot;B2&quot;)) %&gt;% 
  mutate(combined = str_c(model, estimate, sep = &quot;: &quot;)) %&gt;% 
  rename(lower_pi = &#39;5.5%&#39;, upper_pi = &#39;94.5%&#39;) %&gt;% 
  ggplot() +
  geom_vline(xintercept = 0, colour = &quot;grey20&quot;, alpha = 0.5, 
             linetype = &quot;dashed&quot;) +
  geom_pointrange(aes(x = mean, xmin = lower_pi, xmax = upper_pi,  
                      combined, colour = estimate), size = 0.9,
                  show.legend = FALSE) +
  scale_color_manual(values = c(red, blue)) +
  labs(y = NULL, x = &quot;Estimate&quot;) +
  theme_classic()</code></pre>
<div class="figure">
<img src="/post/chapter5_files/figure-html/5M1%20part%205-1.png" alt="*Coeffficient plot for the bivariate models 1 and 2 and the multiple regression model 3*" width="672" />
<p class="caption">
(#fig:5M1 part 5)<em>Coeffficient plot for the bivariate models 1 and 2 and the multiple regression model 3</em>
</p>
</div>
<p>We can see that the bivariate regressions falsely estimate that the second predictor is related to the outcome. But in a multiple regression framework, we get the right answer: There is no new information included in the second predictor, once we know about the first predictor.<br />
We can make a directed acyclic graph (DAG) using the <code>ggdad</code> package for this.</p>
<pre class="r"><code>tibble(name = c(&quot;Outcome&quot;, &quot;Predictor1&quot;, &quot;Predictor2&quot;),
       x    = c(1, 0, 2),
       y    = c(0, 1, 1)) %&gt;% 
  dagify(Outcome ~ Predictor1,
         Predictor2 ~ Predictor1,
         coords = .) %&gt;% 
  ggplot(aes(x = x, y = y, xend = xend, yend = yend)) +
  geom_dag_node(color = red, alpha = 0.5) +
  geom_dag_text(aes(label = abbreviate(name)), color = blue) +
  geom_dag_edges(edge_color = blue) +
  theme_void()</code></pre>
<div class="figure">
<img src="/post/chapter5_files/figure-html/5M1%20part%206-1.png" alt="*Directed acyclic graph for Question 5M1*" width="672" />
<p class="caption">
(#fig:5M1 part 6)<em>Directed acyclic graph for Question 5M1</em>
</p>
</div>
</div>
<div id="question-5m2" class="section level2" number="3.2">
<h2><span class="header-section-number">3.2</span> Question 5M2</h2>
<p><strong>Invent your own example of a masked relationship. An outcome variable should be correlated with both predictor variables, but in opposite directions. And the two predictor variables should be correlated with one another.</strong><br />
We can use the same steps as in 5M1:<br />
First we simulate the data. We create the first predictor from a normal distribution and let the second predictor be correlated to the first one by sampling from the means of <code>pred_1</code>. The outcome is then simulated whit a positive correlation to <code>pred_1</code> and negatively correlated to <code>pred_2</code>.</p>
<pre class="r"><code>N &lt;- 100
dfr &lt;- tibble(pred_1 = rnorm(N, sd = 3), 
              pred_2 = rnorm(N, pred_1, sd = 0.5), 
              out_var = rnorm(N, pred_1 - pred_2)) %&gt;% 
  mutate(across(everything(), scale))</code></pre>
<p>Now we approximate two bivariate and one multiple regression from the data. The model estimates are then tidied.</p>
<pre class="r"><code># bivariate regression of predictor 1 on the outcome
m1 &lt;- alist(out_var ~ dnorm(mu, sigma),
            mu &lt;- a + B1*pred_1,
            a ~ dnorm(0, 0.2), 
            B1 ~ dnorm(0, 0.5),
            sigma ~ dexp(1)) %&gt;% 
  quap(., data = dfr) %&gt;% 
  precis() %&gt;% 
  as_tibble(rownames = &quot;estimate&quot;)



# bivariate regression of predictor 2 on the outcome
m2 &lt;- alist(out_var ~ dnorm(mu, sigma),
            mu &lt;- a + B2*pred_2,
            a ~ dnorm(0, 0.2), 
            B2 ~ dnorm(0, 0.5),
            sigma ~ dexp(1)) %&gt;% 
  quap(., data = dfr) %&gt;% 
  precis() %&gt;% 
  as_tibble(rownames = &quot;estimate&quot;)



# multiple linear regression of predictor 1 and predictor 2 on the outcome
m3 &lt;- alist(out_var ~ dnorm(mu, sigma),
            mu &lt;- a + B1*pred_1 + B2*pred_2,
            a ~ dnorm(0, 0.2),
            B1 ~ dnorm(0, 0.5),
            B2 ~ dnorm(0, 0.5),
            sigma ~ dexp(1)) %&gt;% 
  quap(., data = dfr) %&gt;% 
  precis() %&gt;% 
  as_tibble(rownames = &quot;estimate&quot;)</code></pre>
<p>Now we combine all estimates from the model in a data frame, wrangle and plot it.</p>
<pre class="r"><code>full_join(m1, m2) %&gt;% 
  full_join(m3) %&gt;% 
  add_column(model = rep(paste(&quot;Model&quot;, 1:3), c(3, 3, 4))) %&gt;% 
  filter(estimate %in% c(&quot;B1&quot;, &quot;B2&quot;)) %&gt;% 
  mutate(combined = str_c(model, estimate, sep = &quot;: &quot;)) %&gt;% 
  rename(lower_pi = &#39;5.5%&#39;, upper_pi = &#39;94.5%&#39;) %&gt;% 
  ggplot() +
  geom_pointrange(aes(x = mean, xmin = lower_pi, xmax = upper_pi,  
                      combined, colour = estimate), size = 1, 
                  show.legend = FALSE) +
  geom_vline(xintercept = 0, colour = &quot;grey20&quot;, 
             linetype = &quot;dashed&quot;, alpha = 0.5) +
  scale_color_manual(values = c(red, blue)) +
  labs(y = NULL, x = &quot;Estimate&quot;) +
  theme_classic()</code></pre>
<div class="figure">
<img src="/post/chapter5_files/figure-html/5M2%20part%203-1.png" alt="*Coefficient plot for the bivariate models 1 and 2 and the multiple regression model 3*" width="672" />
<p class="caption">
(#fig:5M2 part 3)<em>Coefficient plot for the bivariate models 1 and 2 and the multiple regression model 3</em>
</p>
</div>
<p>We can see that the relationship between the outcome and each predictor is masked in a bivariate regression, but emerges in a multiple regression. As the first and the second predictor are correlated, they probably share a cause that is unobserved. Let’s build a DAG for this as well.</p>
<pre class="r"><code>tibble(name = c(&quot;Outcome&quot;, &quot;Pred1&quot;, &quot;Pred2&quot;, &quot;Unobserved&quot;),
       x    = c(1, 0, 2, 1),
       y    = c(0, 1, 1, 1.5)) %&gt;% 
  dagify(Outcome ~ Pred1 + Pred2,
         Pred1 ~ Unobserved,
         Pred2 ~ Unobserved,
         coords = .) %&gt;% 
  ggplot(aes(x = x, y = y, xend = xend, yend = yend)) +
  geom_dag_node(color = red, alpha = 0.5) +
  geom_dag_text(color = blue) +
  geom_dag_edges(edge_color = blue) +
  theme_void()</code></pre>
<div class="figure">
<img src="/post/chapter5_files/figure-html/5M2%20part%204-1.png" alt="*Directed acyclic graph for question 5M2*" width="672" />
<p class="caption">
(#fig:5M2 part 4)<em>Directed acyclic graph for question 5M2</em>
</p>
</div>
</div>
<div id="question-5m3" class="section level2" number="3.3">
<h2><span class="header-section-number">3.3</span> Question 5M3</h2>
<p><strong>It is sometimes observed that the best predictor of fire risk is the presence of firefighters—States and localities with many firefighters also have more fires. Presumably firefighters do not cause fires. Nevertheless, this is not a spurious correlation. Instead fires cause firefighters. Consider the same reversal of causal inference in the context of the divorce and marriage data. How might a high divorce rate cause a higher marriage rate? Can you think of a way to evaluate this relationship, using multiple regression?</strong></p>
<p>After a divorce, there are two new individuals on the “wedding market”. Divorce rate <em>D</em> could hence be related to marriage rate <em>M</em> by increasing the pool of potential individuals one can marry. This could be tested by tracking each individual after a divorce to see whether they get re-married again. This re-marriage rate <em>R</em> could then be used in a multiple linear regression framework, where marriage rate is the outcome, and divorce rate and re-marriage rate are the predictors. If divorce rate was related to marriage rate in a bivariate regression framework, but not when adding re-marriage rate in a multiple regression, then re-marriage is the driving force for the spurious correlation between divorce and marriage rate.</p>
<pre class="r"><code>tibble(name = c(&quot;M&quot;, &quot;D&quot;, &quot;R&quot;),
       x    = c(1, 0, 2),
       y    = c(0, 1, 1)) %&gt;% 
  dagify(M ~ R,
         R ~ D, 
         coords = .) %&gt;% 
  ggplot(aes(x = x, y = y, xend = xend, yend = yend)) +
  geom_dag_node(color = red, alpha = 0.5) +
  geom_dag_text(color = blue) +
  geom_dag_edges(edge_color = blue) +
  theme_void()</code></pre>
<div class="figure">
<img src="/post/chapter5_files/figure-html/5M3%20part%201-1.png" alt="*Directed acyclic graph for question 5M3*" width="672" />
<p class="caption">
(#fig:5M3 part 1)<em>Directed acyclic graph for question 5M3</em>
</p>
</div>
</div>
<div id="question-5m4" class="section level2" number="3.4">
<h2><span class="header-section-number">3.4</span> Question 5M4</h2>
<p><strong>In the divorce data, States with high numbers of Mormons (members of The Church of Jesus Christ of Latter-day Saints, LDS) have much lower divorce rates than the regression models expected. Find a list of LDS population by State and use those numbers as a predictor variable, predicting divorce rate using marriage rate, median age at marriage, and percent LDS population (possibly standardized). You may want to consider transformations of the raw percent LDS variable.</strong></p>
<p>First, let’s load the divorce data, assign better names and standardise each parameter.</p>
<pre class="r"><code>data(&quot;WaffleDivorce&quot;)

d_waffle &lt;- WaffleDivorce %&gt;% 
  as_tibble() %&gt;% 
  select(marriage = Marriage, age_marriage = MedianAgeMarriage, 
         divorce = Divorce, location = Location)</code></pre>
<p>After a quick google search, I found a downloadable csv data from <a href="https://worldpopulationreview.com/state-rankings/mormon-population-by-state">worldpoulationreview</a>. I have downloaded it and added the file to my github repo, from which you can directly assess the data without leaving the r-studio environment.</p>
<pre class="r"><code>mormons &lt;- read_csv(
  file = &quot;https://raw.githubusercontent.com/Ischi94/statistical-rethinking/master/mormons.csv&quot;) %&gt;% 
  mutate(lds = mormonPop/Pop) %&gt;% 
  select(location = State, lds)</code></pre>
<p>As we have the ‘location’ column in both data frames, we can use it as an ID for joining both into one table.</p>
<pre class="r"><code>mormons %&gt;% 
  full_join(d_waffle) %&gt;% 
  drop_na() %&gt;% 
  ggplot() +
  geom_density(aes(lds)) +
  theme_minimal()</code></pre>
<div class="figure">
<img src="/post/chapter5_files/figure-html/5M4%20part%203-1.png" alt="*Distribution of the added parameter percentage mormons per state (lds)*" width="672" />
<p class="caption">
(#fig:5M4 part 3)<em>Distribution of the added parameter percentage mormons per state (lds)</em>
</p>
</div>
<p>Note that I have removed all <code>NA</code>s. The resulting distribution for the lds (% mormons per state) is totally skewed. Let’s see if a log-transformation can deal with this skew:</p>
<pre class="r"><code>mormons %&gt;% 
  full_join(d_waffle) %&gt;% 
  drop_na() %&gt;% 
  mutate(log_lds = log(lds)) %&gt;% 
  ggplot() +
  geom_density(aes(log_lds)) +
  theme_minimal()</code></pre>
<div class="figure">
<img src="/post/chapter5_files/figure-html/5M4%20part%204-1.png" alt="*The log-distribution of the added parameter percentage mormons per state (log_lds)*" width="672" />
<p class="caption">
(#fig:5M4 part 4)<em>The log-distribution of the added parameter percentage mormons per state (log_lds)</em>
</p>
</div>
<p>Now that looks much better. So let’s keep working with the log of lds. We can directly standardise the resulting variable for an easier prior decision.</p>
<pre class="r"><code>d_waffle_sd &lt;- mormons %&gt;% 
  full_join(d_waffle) %&gt;% 
  drop_na() %&gt;% 
  mutate(log_lds = log(lds)) %&gt;% 
  mutate(across(is.numeric, standardize))</code></pre>
<p>We are ready to build a model and approximate the posterior. This might look complicated but can be broken down into: Defining the model using <code>alist()</code>, approximating the posterior using <code>quap()</code>, getting the mean and spread around the mean for each estimate using <code>precis()</code>, some data wrangling to get in the right plotting format, and finally plotting with <code>ggplot()</code>.</p>
<pre class="r"><code>m_lds &lt;- alist(divorce ~ dnorm(mu, sigma),
               mu &lt;- a + Ba*age_marriage + Bm*marriage + Bl*log_lds, 
               a ~ dnorm(0, 0.2), 
               Ba ~ dnorm(0, 0.5), 
               Bm ~ dnorm(0, 0.5), 
               Bl ~ dnorm(0, 0.5),
               sigma ~ dexp(1)) %&gt;% 
  quap(., data = d_waffle_sd) 

m_lds %&gt;% 
  precis(.) %&gt;% 
  as_tibble(rownames = &quot;estimate&quot;) %&gt;% 
  filter(str_detect(estimate, &quot;^B&quot;)) %&gt;% 
  rename(lower_pi = &#39;5.5%&#39;, upper_pi = &#39;94.5%&#39;) %&gt;% 
  mutate(estimate = c(&quot;Age at marriage&quot;, &quot;Marriage rate&quot;, &quot;Log Mormons [%]&quot;)) %&gt;% 
  ggplot() +
  geom_vline(xintercept = 0, linetype = &quot;dashed&quot;, alpha = 0.5) +
  geom_pointrange(aes(x = mean, xmin = lower_pi, xmax = upper_pi, estimate,
                      colour = estimate), size = 0.7, show.legend = FALSE) +
  scale_colour_manual(values = c(blue, red, yellow)) +
  labs(x = &quot;Estimate&quot;, y = NULL) +
  theme_classic()</code></pre>
<div class="figure">
<img src="/post/chapter5_files/figure-html/5M4%20part%206-1.png" alt="*Coefficient plot for the model Divorce rate ~ Age at Marriage + Marriage rate + log Mormons*" width="672" />
<p class="caption">
(#fig:5M4 part 6)<em>Coefficient plot for the model Divorce rate ~ Age at Marriage + Marriage rate + log Mormons</em>
</p>
</div>
<p>What we can see is that the magnitude in percentage of LDS per state is negatively related to divorce rate. There is no longer a consistent trend for marriage rate and age at marriage is still negatively related to divorce rate. This indicates that states were people were getting married at a higher age as well as states with
higher percentages of Mormons have lower divorce rates.<br />
We can additionally check the model fit by using a posterior predictive plot. We simple call <code>link()</code> on the actual data, which simple means sample from the posterior for each <code>divorce</code> value in the data. We then calculate the mean and the percentile interval using some nested tibbles and label those states which are outliers (when the difference between the observed divorce rate and predicted divorce rate is greater than |1|).</p>
<pre class="r"><code>link(m_lds) %&gt;% 
  as_tibble() %&gt;% 
  pivot_longer(cols = everything(), values_to = &quot;pred_divorce&quot;) %&gt;% 
  group_by(name) %&gt;% 
  nest() %&gt;% 
  mutate(pred_divorce = map(data, &quot;pred_divorce&quot;), 
         mean_pred = map_dbl(pred_divorce, mean), 
         pi_pred = map(pred_divorce, PI), 
         pi_low = map_dbl(pi_pred, pluck(1)), 
         pi_high = map_dbl(pi_pred, pluck(2))) %&gt;% 
  ungroup() %&gt;% 
  add_column(obs_divorce = d_waffle_sd$divorce, 
             location = d_waffle_sd$location) %&gt;% 
  select(-c(name, data, pred_divorce, pi_pred)) %&gt;% 
  mutate(outlier = obs_divorce - mean_pred, 
         outlier = if_else(outlier &gt;= 1 | outlier &lt;= -1, location, NA_character_)) %&gt;% 
  ggplot(aes(x = obs_divorce, y = mean_pred)) +
  geom_abline(slope = 1, intercept = 0, 
              linetype = &quot;dashed&quot;, size = 1.2, colour = yellow) +
  geom_pointrange(aes(ymin = pi_low, ymax = pi_high), 
                  colour = blue) +
  geom_label(aes(label = outlier)) +
  labs(x = &quot;Observed Divorce&quot;, y = &quot;Predicted Divorce&quot;) +
  theme_minimal() +
  theme(panel.grid.minor = element_blank(), 
        panel.grid.major = element_line(colour = &quot;grey97&quot;))</code></pre>
<div class="figure">
<img src="/post/chapter5_files/figure-html/5M4%20part%207-1.png" alt="*Posterior predictive plot for the model Divorce rate ~ Age at Marriage + Marriage rate + log Mormons*" width="672" />
<p class="caption">
(#fig:5M4 part 7)<em>Posterior predictive plot for the model Divorce rate ~ Age at Marriage + Marriage rate + log Mormons</em>
</p>
</div>
</div>
<div id="question-5m5" class="section level2" number="3.5">
<h2><span class="header-section-number">3.5</span> Question 5M5</h2>
<p><strong>One way to reason through multiple causation hypotheses is to imagine detailed mechanisms through which predictor variables may influence outcomes. For example, it is sometimes argued that the price of gasoline (predictor variable) is positively associated with lower obesity rates (outcome variable). However, there are at least two important mechanisms by which the price of gas could reduce obesity. First, it could lead to less driving and therefore more exercise. Second, it could lead to less driving, which leads to less eating out, which leads to less consumption of huge restaurant meals. Can you outline one or more multiple regressions that address these two mechanisms? Assume you can have any predictor data you need.</strong></p>
<p>One could use a multiple regression framework with three predictors, the first one being price of gasoline. For the second one, we need to track the time spent walking of each individual to measure the effect of driving less. For the third one, we need to track the frequency of meals consumed at restaurants for each individual. a potential model could hence be:</p>
<p><span class="math display">\[\mu_i = \alpha + \beta_g G_i + \beta_w W_i + \beta_f  F_i\]</span>
where <span class="math inline">\(\mu\)</span> is the mean obesity rate, <em>G</em> the price of gasoline, <em>W</em> the walking rate
(per day), and <em>F</em> the amount of restaurant food.</p>
</div>
</div>
<div id="hard-practices-online" class="section level1" number="4">
<h1><span class="header-section-number">4</span> Hard practices online</h1>
<p><strong>All three exercises below use the same data, <code>data(foxes)</code> (part of rethinking).The urban fox (Vulpes vulpes) is a successful exploiter of human habitat. Since urban foxes move in packs and defend territories, data on habitat quality and population density is also included. The data frame has five columns:</strong></p>
<ol style="list-style-type: decimal">
<li>group: Number of the social group the individual fox belongs to</li>
<li>avgfood: The average amount of food available in the territory</li>
<li>groupsize: The number of foxes in the social group</li>
<li>area: Size of the territory</li>
<li>weight: Body weight of the individual fox</li>
</ol>
<div id="question-5h1" class="section level2" number="4.1">
<h2><span class="header-section-number">4.1</span> Question 5H1</h2>
<p><strong>Fit two bivariate Gaussian regressions, using quap: (1) body weight as a linear function of territory size (area), and (2) body weight as a linear function of groupsize. Plot the results of these regressions, displaying the MAP regression line and the 95% interval of the mean. Is either variable important for predicting fox body weight?</strong></p>
<p>Let’s load the data and standardise all variables despite <code>group</code>, which seems to be a dummy variable.</p>
<pre class="r"><code>data(&quot;foxes&quot;)

foxes_std &lt;- foxes %&gt;% 
  mutate(across(-group, standardize))</code></pre>
<p>Let’s fit the first bivariate regression with <code>body_weight</code> ~ <code>area</code>. Similar to previous examples, standardising the variables really helps with selecting priors that cover realistic relationships.</p>
<pre class="r"><code>m_1 &lt;- alist(weight ~ dnorm(mu, sigma), 
             mu &lt;- a + Ba*area, 
             a ~ dnorm(0, 0.2), 
             Ba ~ dnorm(0, 0.5), 
             sigma ~ dexp(1)) %&gt;% 
  quap(., data = foxes_std)</code></pre>
<p>For posterior sampling, I define a sequence of values for which I want results and the number of samples I want to attain. I will use this sequence the sampling throughout many of the subsequent questions.</p>
<pre class="r"><code>s &lt;- seq(from = -2, to = 2, length.out = 30)
N &lt;- 1e3</code></pre>
<p>Now we can apply our model to each sequence value with <code>link()</code>, calculate the mean and percentile intervals with the help of <code>purrr::map</code> functions applied to list columns. After a bit of data wrangling, we can directly pipe the data to <code>ggplot()</code>.</p>
<pre class="r"><code>m_1 %&gt;% 
  link(data = list(area = s), n = N) %&gt;% 
  as_tibble() %&gt;% 
  pivot_longer(cols = everything(), values_to = &quot;pred_weight&quot;) %&gt;% 
  add_column(area = rep(s, N)) %&gt;% 
  group_by(area) %&gt;% 
  nest() %&gt;% 
  mutate(pred_weight = map(data, &quot;pred_weight&quot;), 
         mean_weight = map_dbl(pred_weight, mean), 
         pi = map(pred_weight, PI), 
         lower_pi = map_dbl(pi, pluck(1)), 
         upper_pi = map_dbl(pi, pluck(2))) %&gt;% 
  select(area, mean_weight, lower_pi, upper_pi) %&gt;% 
  ggplot() +
  geom_ribbon(aes(area, ymin = lower_pi, ymax = upper_pi), 
              fill = yellow, alpha = 0.3) +
  geom_line(aes(area, mean_weight), 
            size = 1.5, colour = blue) +
  labs(x = &quot;Area (std)&quot;, y = &quot;Weight (std)&quot;) +
  theme_minimal()</code></pre>
<div class="figure">
<img src="/post/chapter5_files/figure-html/5H1%20online%20part%204-1.png" alt="*Body weight as a linear function of territory size (area) within a bivariate regression framework*" width="672" />
<p class="caption">
(#fig:5H1 online part 4)<em>Body weight as a linear function of territory size (area) within a bivariate regression framework</em>
</p>
</div>
<p>And we can repeat the same steps for <code>weight</code> ~ <code>groupsize</code>.</p>
<pre class="r"><code>m_2 &lt;- alist(weight ~ dnorm(mu, sigma), 
             mu &lt;- a + Bg*groupsize, 
             a ~ dnorm(0, 0.2), 
             Bg ~ dnorm(0, 0.5), 
             sigma ~ dexp(1)) %&gt;% 
  quap(., data = foxes_std)


m_2 %&gt;% 
  link(data = list(groupsize = s), n = N) %&gt;% 
  as_tibble() %&gt;% 
  pivot_longer(cols = everything(), values_to = &quot;pred_weight&quot;) %&gt;% 
  add_column(groupsize = rep(s, N)) %&gt;% 
  group_by(groupsize) %&gt;% 
  nest() %&gt;% 
  mutate(pred_weight = map(data, &quot;pred_weight&quot;), 
         mean_weight = map_dbl(pred_weight, mean), 
         pi = map(pred_weight, PI), 
         lower_pi = map_dbl(pi, pluck(1)), 
         upper_pi = map_dbl(pi, pluck(2))) %&gt;% 
  select(groupsize, mean_weight, lower_pi, upper_pi) %&gt;% 
  ggplot() +
  geom_ribbon(aes(groupsize, ymin = lower_pi, ymax = upper_pi), 
              fill = yellow, alpha = 0.3) +
  geom_line(aes(groupsize, mean_weight), 
            size = 1.5, colour = blue) +
  labs(x = &quot;Groupsize (std)&quot;, y = &quot;Weight (std)&quot;) +
  theme_minimal()</code></pre>
<div class="figure">
<img src="/post/chapter5_files/figure-html/5H1%20online%20part%205-1.png" alt="*Body weight as a linear function of groupsize within a bivariate regression framework*" width="672" />
<p class="caption">
(#fig:5H1 online part 5)<em>Body weight as a linear function of groupsize within a bivariate regression framework</em>
</p>
</div>
<p>While <code>area</code> shows no consistent trend, <code>groupsize</code> seems to be negatively correlated to <code>weight</code>.</p>
</div>
<div id="question-5h2" class="section level2" number="4.2">
<h2><span class="header-section-number">4.2</span> Question 5H2</h2>
<p><strong>Now fit a multiple linear regression with weight as the outcome and both area and groupsize as predictor variables. Plot the predictions of the model for each predictor, holding the other predictor constant at its mean. What does this model say about the importance of each variable? Why do you get different results than you got in the exercise just above?</strong></p>
<p>Here’s the model:</p>
<pre class="r"><code>m_3 &lt;- alist(weight ~ dnorm(mu, sigma), 
             mu &lt;- a + Ba*area + Bg*groupsize, 
             a ~ dnorm(0, 0.2), 
             Ba ~ dnorm(0, 0.5), 
             Bg ~ dnorm(0, 0.5), 
             sigma ~ dexp(1)) %&gt;% 
  quap(., data = foxes_std)</code></pre>
<p>One advantage of standardising the predictor variables (using z-scores) is that we know that their mean is approximately zero:</p>
<pre class="r"><code>mean(foxes_std$area) %&gt;% 
  near(0)</code></pre>
<pre><code>## [1] TRUE</code></pre>
<p>This means that we can keep one predictor at 0 while looking at the relationship of the other predictor to the outcome. We start by looking at <code>weight</code> ~ <code>area</code> while keeping <code>groupsize</code> at 0.</p>
<pre class="r"><code>list(area = s, groupsize = 0) %&gt;% 
  link(m_3, data = ., n = N) %&gt;% 
  as_tibble() %&gt;% 
  pivot_longer(cols = everything(), values_to = &quot;pred_weight&quot;) %&gt;% 
  add_column(area = rep(s, N)) %&gt;% 
  group_by(area) %&gt;% 
  nest() %&gt;% 
  mutate(pred_weight = map(data, &quot;pred_weight&quot;), 
         mean_weight = map_dbl(pred_weight, mean), 
         pi = map(pred_weight, PI), 
         lower_pi = map_dbl(pi, pluck(1)), 
         upper_pi = map_dbl(pi, pluck(2))) %&gt;% 
  select(area, mean_weight, lower_pi, upper_pi) %&gt;% 
  ggplot() +
  geom_ribbon(aes(area, ymin = lower_pi, ymax = upper_pi), 
              fill = yellow, alpha = 0.3) +
  geom_line(aes(area, mean_weight), 
            size = 1.5, colour = blue) +
  labs(x = &quot;Area (std)&quot;, 
       y = &quot;Weight (std)&quot;) +
  theme_minimal()</code></pre>
<div class="figure">
<img src="/post/chapter5_files/figure-html/5H2%20online%20part%203-1.png" alt="*The relationship between weight and area in a muliple regression framework while keeping standardised groupsize at 0*" width="672" />
<p class="caption">
(#fig:5H2 online part 3)<em>The relationship between weight and area in a muliple regression framework while keeping standardised groupsize at 0</em>
</p>
</div>
<p>The same for <code>weight</code> ~ <code>groupsize</code> while keeping <code>area</code> at 0.</p>
<pre class="r"><code>list(groupsize = s, area = 0) %&gt;% 
  link(m_3, data = ., n = N) %&gt;% 
  as_tibble() %&gt;% 
  pivot_longer(cols = everything(), values_to = &quot;pred_weight&quot;) %&gt;% 
  add_column(groupsize = rep(s, N)) %&gt;% 
  group_by(groupsize) %&gt;% 
  nest() %&gt;% 
  mutate(pred_weight = map(data, &quot;pred_weight&quot;), 
         mean_weight = map_dbl(pred_weight, mean), 
         pi = map(pred_weight, PI), 
         lower_pi = map_dbl(pi, pluck(1)), 
         upper_pi = map_dbl(pi, pluck(2))) %&gt;% 
  select(groupsize, mean_weight, lower_pi, upper_pi) %&gt;% 
  ggplot() +
  geom_ribbon(aes(groupsize, ymin = lower_pi, ymax = upper_pi), 
              fill = yellow, alpha = 0.3) +
  geom_line(aes(groupsize, mean_weight), 
            size = 1.5, colour = blue) +
  labs(title = &quot;Area (std) = 0&quot;, x = &quot;Groupsize (std)&quot;, 
       y = &quot;Weight (std)&quot;) +
  theme_minimal()</code></pre>
<div class="figure">
<img src="/post/chapter5_files/figure-html/5H2%20online%20part%204-1.png" alt="*The relationship between weight and groupsize in a muliple regression framework while keeping standardised area at 0*" width="672" />
<p class="caption">
(#fig:5H2 online part 4)<em>The relationship between weight and groupsize in a muliple regression framework while keeping standardised area at 0</em>
</p>
</div>
<p>This a simple but great example of a masked relationship. Area is positively related to weight, while groupsize is negatively related, canceling each other out. The multiple regression can unmask this, showing the real relationships between the outcome and the predictors.</p>
</div>
<div id="question-5h3" class="section level2" number="4.3">
<h2><span class="header-section-number">4.3</span> Question 5H3</h2>
<p><strong>Finally, consider the avgfood variable. Fit two more multiple regressions: (1) body weight as an additive function of avgfood and groupsize, and (2) body weight as an additive function of all three variables,avgfood and groupsize and area. Compare the results of these models to the previous models you’ve fit, in the first two exercises.</strong></p>
<p>Let’s fit the multiple regression of body weight as an additive function of <code>avgfood</code> and <code>groupsize</code>.</p>
<pre class="r"><code>m_4 &lt;- alist(weight ~ dnorm(mu, sigma), 
             mu &lt;- a + Bf*avgfood + Bg*groupsize, 
             a ~ dnorm(0, 0.2), 
             Bf ~ dnorm(0, 0.5), 
             Bg ~ dnorm(0, 0.5), 
             sigma ~ dexp(1)) %&gt;% 
  quap(. , data = foxes_std)</code></pre>
<p>Same for body weight as an additive function of all three variables,<code>avgfood</code> and <code>groupsize</code> and <code>area</code>.</p>
<pre class="r"><code>m_5 &lt;- alist(weight ~ dnorm(mu, sigma), 
             mu &lt;- a + Bf*avgfood + Bg*groupsize + Ba*area, 
             a ~ dnorm(0, 0.2), 
             Bf ~ dnorm(0, 0.5), 
             Bg ~ dnorm(0, 0.5), 
             Ba ~ dnorm(0, 0.5),
             sigma ~ dexp(1)) %&gt;% 
  quap(. , data = foxes_std)</code></pre>
<p>For convenience, I will define a function <code>tidy_coef()</code> that takes a <code>quap()</code> model as input and returns a tidy tibble with all <span class="math inline">\(\beta\)</span> estimates of the model.</p>
<pre class="r"><code>tidy_coef &lt;- function(model_input) {
  suppressWarnings(
    
    model_input %&gt;% 
      precis(.) %&gt;% 
      as_tibble(rownames = &quot;estimate&quot;) %&gt;% 
      filter(str_detect(estimate, &quot;^b|B&quot; ) )
  
    )
}</code></pre>
<p>We can use this function to tidy all models at once by putting them in a list and calling the function with the help of <code>purrr:map()</code>. The rest is simple data wrangling to bring it in a tidy plotting format.</p>
<pre class="r"><code>list(m_1, m_2, m_3, m_4, m_5) %&gt;% 
  map(tidy_coef) %&gt;% 
  enframe(name = &quot;model&quot;) %&gt;%
  unnest(value) %&gt;% 
  mutate(coef_mod = str_c(&quot;Model&quot;, model, sep = &quot; &quot;), 
         coef_mod = str_c(coef_mod, estimate, sep = &quot;: &quot;)) %&gt;% 
  rename(lower_pi = &#39;5.5%&#39;, upper_pi = &#39;94.5%&#39;)  %&gt;%  
  ggplot() +
  geom_vline(xintercept = 0, colour = &quot;grey40&quot;)  +
  geom_pointrange(aes(x = mean, xmin = lower_pi, xmax = upper_pi, y = coef_mod, 
                  colour = estimate)) +
  scale_colour_discrete(name = &quot;Predictor&quot;, 
                        labels = c(&quot;Area&quot;, &quot;Food&quot;, &quot;Groupsize&quot;), 
                        type = c(red, blue, yellow)) +
  scale_y_discrete(labels = c(&quot;Model 1&quot;, &quot;Model 2&quot;, &quot;&quot;, &quot;Model 3&quot;, 
                              &quot;&quot;, &quot;Model 4&quot;, &quot;&quot;, &quot;&quot;, &quot;Model 5&quot;)) +
  geom_hline(yintercept = c(0.5, 1.5, 2.5, 4.5, 6.5, 9.5),
             linetype = &quot;dotted&quot;, colour = &quot;grey80&quot;) +
  labs(x = &quot;Estimate&quot;, y = NULL) +
  theme_minimal() + 
  theme(panel.grid.major.y = element_blank())</code></pre>
<div class="figure">
<img src="/post/chapter5_files/figure-html/5H3%20online%20part%204-1.png" alt="*Coefficient plot for the bivariate models 1 and 2 and the multiple regressions 3, 4 and 5 with weight as the outcome*" width="672" />
<p class="caption">
(#fig:5H3 online part 4)<em>Coefficient plot for the bivariate models 1 and 2 and the multiple regressions 3, 4 and 5 with weight as the outcome</em>
</p>
</div>
<p><code>avgfood</code> is positively related to <code>weight</code> in a model with <code>avgfood</code> and <code>area</code> as
predictors. This relationship is lost when adding <code>groupsize</code> as a predictor to
the model.</p>
<p><strong>(a) Is avgfood or area a better predictor of bodyweight? If you had to choose one or the other to include in a model, which would it be? Support your assessment with any tables or plots you choose.</strong></p>
<p>Comparing Model 3, 4, and 5 (see plot above) shows that <code>avgfood</code> generally has a higher effect on <code>weight</code> than <code>area</code>, even if the uncertainty is a bit higher. I would therefore choose <code>avgfood</code>.</p>
<p>However, I think that this really depends on the research question and what is already known about fox behaviour. Looking at the coefficient estimates, both are positively related to weight, but effects are reduced when they are in the same model (see b below) Assuming that more area for a fox group increases
their access to food, I would use area as it is the direct causal variable. But it could as well be that more food increases the area you can roam as a fox, as you have more power. In this case, I would use food as a predictor.</p>
<p><strong>(b) When both avgfood or area are in the same model, their effects are reduced (closer to zero) and their standard errors are larger than when they are included in separate models. Can you explain this result?</strong></p>
<p><code>area</code> and <code>avgfood</code> are strongly correlated.</p>
<pre class="r"><code>ggplot(foxes_std) +
  geom_point(aes(area, avgfood), size = 2.5, shape = 21, 
             fill = red, colour = &quot;grey20&quot;) +
  labs(y = &quot;Food&quot;, x = &quot;Area&quot;) +
  theme_minimal()</code></pre>
<div class="figure">
<img src="/post/chapter5_files/figure-html/5H3%20online%20part%205-1.png" alt="*Multicollinearity between area and avgfood can decrease their descriptive power when used together in a multiple regression*" width="672" />
<p class="caption">
(#fig:5H3 online part 5)<em>Multicollinearity between area and avgfood can decrease their descriptive power when used together in a multiple regression</em>
</p>
</div>
<p>This phenomenon is called multicollinearity (what a word, eh!). When adding both parameters as predictors in a multiple regression, the partial effect of each becomes smaller after controlling for the other (this is what we can see when comparing Model 3, 4, and 5). It could be that both parameters share a common unobserved cause, or that one parameter causes the other. Either way, it would be wiser to include only one of these parameter (food OR area) in the final model.</p>
</div>
</div>
<div id="hard-practices-print" class="section level1" number="5">
<h1><span class="header-section-number">5</span> Hard practices print</h1>
<div id="question-5h1-1" class="section level2" number="5.1">
<h2><span class="header-section-number">5.1</span> Question 5H1</h2>
<p><strong>In the divorce example, suppose the DAG is: M -&gt; A -&gt; D. What are the implied conditional independencies of the graph? Are the data consistent with it?</strong></p>
<p>To get the conditional independencies, we can use the <code>daggity</code> package. For plotting, however, I still prefer the ggplot2 extension to it, <code>ggdad</code>.</p>
<pre class="r"><code>tibble(name = c(&quot;M&quot;, &quot;A&quot;, &quot;D&quot;),
       x    = c(0, 1, 2),
       y    = c(1, 1, 1)) %&gt;% 
  dagify(D ~ A,
         A ~ M,
         coords = .) %&gt;% 
  ggplot(aes(x = x, y = y, xend = xend, yend = yend)) +
  geom_dag_node(color = red, alpha = 0.5) +
  geom_dag_text(aes(label = name), color = blue) +
  geom_dag_edges(edge_color = blue) +
  theme_void()</code></pre>
<div class="figure">
<img src="/post/chapter5_files/figure-html/5H1%20print%20part%201-1.png" alt="*Directed acyclic graph for marriage rate (M), medium age at marriage (a) and divorce rate (D)*" width="672" />
<p class="caption">
(#fig:5H1 print part 1)<em>Directed acyclic graph for marriage rate (M), medium age at marriage (a) and divorce rate (D)</em>
</p>
</div>
<p>So let’s see whether there are any implied conditional independencies.</p>
<pre class="r"><code>library(dagitty)

dagitty(&#39;dag{ M -&gt; A -&gt; D }&#39;) %&gt;% 
  impliedConditionalIndependencies()</code></pre>
<pre><code>## D _||_ M | A</code></pre>
<p>Our DAG implies that <code>D</code> is independent of <code>M</code> after conditioning on <code>A</code>. So let’s condition on <code>A</code> by using a multiple linear regression, basically asking: After I already know age at marriage, what additional value is there in also knowing marriage rate?</p>
<pre class="r"><code>d_waffle_sd &lt;- d_waffle %&gt;% 
  mutate(across(is.numeric, standardize))

alist(divorce ~ dnorm(mu, sigma), 
      mu &lt;- a + BM*marriage + BA*age_marriage, 
      a ~ dnorm(0, 0.2), 
      BM ~ dnorm(0, 0.5), 
      BA ~ dnorm(0, 0.5), 
      sigma ~ dexp(1)) %&gt;% 
  quap(. , data = d_waffle_sd) %&gt;% 
  precis() %&gt;% 
  as_tibble(rownames = &quot;estimate&quot;) %&gt;% 
  filter(estimate == &quot;BM&quot;) %&gt;% 
  knitr::kable(digits = 2, caption = &quot;Coefficient estimate for marriage rate regressed on divorce rate&quot;)</code></pre>
<table>
<caption>(#tab:5H1 print part 3)Coefficient estimate for marriage rate regressed on divorce rate</caption>
<thead>
<tr class="header">
<th align="left">estimate</th>
<th align="right">mean</th>
<th align="right">sd</th>
<th align="right">5.5%</th>
<th align="right">94.5%</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">BM</td>
<td align="right">-0.07</td>
<td align="right">0.15</td>
<td align="right">-0.31</td>
<td align="right">0.18</td>
</tr>
</tbody>
</table>
<p>Indeed, D is independent of M after conditioning on A, as there is no consistent relationship between M and D in the model. So up to this point, our assumptions about causal relationships expressed in our DAG still hold.</p>
</div>
<div id="question-5h2-1" class="section level2" number="5.2">
<h2><span class="header-section-number">5.2</span> Question 5H2</h2>
<p>Assuming that the DAD for the divorce example is indeed M -&gt; A -&gt; D, fit a new model and use it to estimate the counterfactual effect of halving a State’s marriage rate M. Use the counterfactual example from the chapter (starting on page 140) as a template.</p>
<p>Let’s build a model that corresponds to our DAG.</p>
<pre class="r"><code>m_5H2 &lt;- alist(
  # M -&gt; A
  age_marriage ~ dnorm(muA, sigmaA), 
  muA &lt;- aA + BM*marriage, 
  aA ~ dnorm(0, 0.2), 
  BM ~ dnorm(0, 0.5), 
  sigmaA ~ dexp(1), 
  
  # A -&gt; D
  divorce ~ dnorm(muD, sigmaD), 
  muD &lt;- aD + BA*age_marriage, 
  aD ~ dnorm(0, 0.2), 
  BA ~ dnorm(0, 0.5), 
  sigmaD ~ dexp(1)) %&gt;% 
  quap(., data = d_waffle_sd)


m_5H2 %&gt;% 
  precis() %&gt;% 
  as_tibble(rownames = &quot;estimate&quot;) %&gt;% 
  knitr::kable(digits = 2, caption = &quot;Coefficient estimates for model m_5H2 corresponding to the DAG M -&gt; A -&gt; D&quot;)</code></pre>
<table>
<caption>(#tab:5H2 print part 1)Coefficient estimates for model m_5H2 corresponding to the DAG M -&gt; A -&gt; D</caption>
<thead>
<tr class="header">
<th align="left">estimate</th>
<th align="right">mean</th>
<th align="right">sd</th>
<th align="right">5.5%</th>
<th align="right">94.5%</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">aA</td>
<td align="right">0.00</td>
<td align="right">0.09</td>
<td align="right">-0.14</td>
<td align="right">0.14</td>
</tr>
<tr class="even">
<td align="left">BM</td>
<td align="right">-0.69</td>
<td align="right">0.10</td>
<td align="right">-0.85</td>
<td align="right">-0.54</td>
</tr>
<tr class="odd">
<td align="left">sigmaA</td>
<td align="right">0.68</td>
<td align="right">0.07</td>
<td align="right">0.57</td>
<td align="right">0.79</td>
</tr>
<tr class="even">
<td align="left">aD</td>
<td align="right">0.00</td>
<td align="right">0.10</td>
<td align="right">-0.16</td>
<td align="right">0.16</td>
</tr>
<tr class="odd">
<td align="left">BA</td>
<td align="right">-0.57</td>
<td align="right">0.11</td>
<td align="right">-0.74</td>
<td align="right">-0.39</td>
</tr>
<tr class="even">
<td align="left">sigmaD</td>
<td align="right">0.79</td>
<td align="right">0.08</td>
<td align="right">0.66</td>
<td align="right">0.91</td>
</tr>
</tbody>
</table>
<p>Just for convenience and as we will do this task iteratively, I will build a function <code>count_plot()</code> that takes samples from a model as well the name of the outcome and the predictor as arguments. The function then returns a counterfactual plot. Note that we don’t need to wrap the variable names into <code>""</code>, as the functions allows tidyeval, making the code more legible.</p>
<pre class="r"><code>count_plot &lt;- function(sim_output, outcome, predictor) {
  sim_output %&gt;%
    as_tibble() %&gt;%
    pivot_longer(cols = everything(), values_to = &quot;{{predictor}}&quot;) %&gt;%
    group_by(name) %&gt;%
    nest() %&gt;%
    add_column(&quot;{{outcome}}&quot; := s) %&gt;%
    ungroup() %&gt;%
    mutate(predictor_pred = map(data, pluck(&quot;{{predictor}}&quot;)),
           predictor_mean = map_dbl(predictor_pred, mean),
           predictor_pi = map(predictor_pred, PI),
           lower_pi = map_dbl(predictor_pi, pluck(1)),
           upper_pi = map_dbl(predictor_pi, pluck(2))) %&gt;%
    ungroup() %&gt;%
    select({{outcome}}, predictor_mean, lower_pi, upper_pi) %&gt;%
    ggplot() +
    geom_ribbon(aes(x = {{outcome}}, ymin = lower_pi, ymax = upper_pi),
                fill = yellow, alpha = 0.3) +
    geom_line(aes({{outcome}}, predictor_mean),
              size = 1.5, colour = blue) +
    labs(x = paste(&quot;manipulated&quot;, as_label(expr({{predictor}}))),
         y = paste(&quot;counterfactual&quot;, as_label(expr({{outcome}})))) +
    theme_minimal()
}</code></pre>
<p>So let’s start with the total counterfactual effect of M on A by simulating posterior observations from M for A and D (in this order) and plucking out the results for A.</p>
<pre class="r"><code>sim(m_5H2, data = list(marriage = s),
    vars = c(&quot;age_marriage&quot;, &quot;divorce&quot;))  %&gt;% 
  pluck(&quot;age_marriage&quot;) %&gt;% 
  count_plot(age_marriage, marriage)</code></pre>
<div class="figure">
<img src="/post/chapter5_files/figure-html/5H2%20print%20part%203-1.png" alt="*Total counterfactual effect of M on A*" width="672" />
<p class="caption">
(#fig:5H2 print part 3)<em>Total counterfactual effect of M on A</em>
</p>
</div>
<p>We can see that counterfactually increasing M decreases A. Now for A on D:</p>
<pre class="r"><code>sim(m_5H2, data = list(age_marriage = s),
    vars = c(&quot;marriage&quot;, &quot;divorce&quot;))  %&gt;% 
  pluck(&quot;divorce&quot;) %&gt;% 
  count_plot(age_marriage, marriage)</code></pre>
<div class="figure">
<img src="/post/chapter5_files/figure-html/5H2%20print%20part%204-1.png" alt="*Total counterfactual effect of A on D*" width="672" />
<p class="caption">
(#fig:5H2 print part 4)<em>Total counterfactual effect of A on D</em>
</p>
</div>
<p>When we decrease A, we increase D. So following the DAG from left to right: Increasing M decreases A, which then increases D. We can check this by plotting the total counterfactual effect of M on D.</p>
<pre class="r"><code>sim(m_5H2, data = list(marriage = s),
    vars = c(&quot;age_marriage&quot;, &quot;divorce&quot;))  %&gt;% 
  pluck(&quot;divorce&quot;) %&gt;% 
  count_plot(divorce, marriage)</code></pre>
<div class="figure">
<img src="/post/chapter5_files/figure-html/5H2%20print%20part%205-1.png" alt="*Total counterfactual effect of M on D*" width="672" />
<p class="caption">
(#fig:5H2 print part 5)<em>Total counterfactual effect of M on D</em>
</p>
</div>
<p>So yes, counterfactually increasing M increases D.</p>
</div>
<div id="question-5m3-1" class="section level2" number="5.3">
<h2><span class="header-section-number">5.3</span> Question 5M3</h2>
<p><strong>Return to the milk energy model, m5.7. Suppose that the true causal relationship among the variables is:</strong></p>
<p><img src="/post/chapter5_files/figure-html/5m3%20print%20part%201-1.png" width="672" /></p>
<p><strong>Now compute the counterfactual effect on K of doubling M. You will need to account for both the direct and indirect paths of causation. Use the counterfactual example from the chapter (starting at page 140) as a template.</strong></p>
<p>Load the data, remove entries with missing data and standardise all variables.</p>
<pre class="r"><code>data(milk)

milk_std &lt;- milk %&gt;% 
  as_tibble() %&gt;% 
  select(mass, kcal.per.g, neocortex.perc) %&gt;% 
  drop_na() %&gt;% 
  mutate(across(everything(), standardize))</code></pre>
<p>Now we can build a model corresponding to the DAG.</p>
<pre class="r"><code>m_milk &lt;- alist(
  # M -&gt; K &lt;- N
  kcal.per.g ~ dnorm(mu, sigma) ,
  mu &lt;- a + bN*neocortex.perc + bM*mass,
  a ~ dnorm(0, 0.2),
  bN ~ dnorm(0 ,0.5),
  bM ~ dnorm(0, 0.5),
  sigma ~ dexp(1),

  ## M -&gt; N
  neocortex.perc ~ dnorm(mu_N, sigma_N),
  mu_N &lt;- aN + bMN*mass,
  aN ~ dnorm(0, 0.2),
  bMN ~ dnorm(0, 0.5),
  sigma_N ~ dexp(1)) %&gt;% 
  quap(., data = milk_std) </code></pre>
<p>To build the counterfactual plot, the function <code>count_plot()</code> comes in handy.</p>
<pre class="r"><code>sim_m1 &lt;- sim(m_milk, data = list(mass = s),
             vars = c(&quot;neocortex.perc&quot;, &quot;kcal.per.g&quot;))  %&gt;% 
  pluck(&quot;kcal.per.g&quot;) 

count_plot(sim_m1, kcal.per.g, mass)</code></pre>
<div class="figure">
<img src="/post/chapter5_files/figure-html/5m3%20print%20part%204-1.png" alt="*Total counterfactual effect of M on K*" width="672" />
<p class="caption">
(#fig:5m3 print part 4)<em>Total counterfactual effect of M on K</em>
</p>
</div>
<p>Doubling M would decrease K, but the relationship is not totally consistent.</p>
</div>
<div id="question-5m4-1" class="section level2" number="5.4">
<h2><span class="header-section-number">5.4</span> Question 5M4</h2>
<p><strong>Here is an open practice problem to engage your imagination. In the divorce data, States in the souther United States have many of the highest divorce rates. Add the South indicator variable to the analysis. First, draw one or more DAGs that represent your ideas for how Southern American culture might influence any of the other three variables (D, M or A). Then list the testable implications of your DAGs, if there are any, and fit one or more models to evaluate the implications. What do you think the influence of “Southerness” is?</strong></p>
<p>Let’s load and standardize the <em>Waffle</em> data, this time with the <code>South</code> variable included.</p>
<pre class="r"><code>divorce_std &lt;- WaffleDivorce %&gt;% 
  as_tibble() %&gt;% 
  select(D = Divorce, M = Marriage, A = MedianAgeMarriage, 
         S = South) %&gt;% 
  mutate(across(-S, standardize), 
         S = if_else(S == 0, 1, 2))</code></pre>
<p>Note that <code>S</code> is categorical (a dummy variable) and is therefore not standardised. Instead, I assign a 1 to each non-southern state and a 2 to each southern state, to enable indexing later on.</p>
<p>Now, southerness (is that a word?) could drive A (medium age at marriage), as a cultural thing. If it is related to culture, it could directly influence D as well. Further, we found in the chapter that A influences both M and D, and M has low influence on D. We can therefore remove M. Let’s draw a DAG.</p>
<pre class="r"><code>tibble(name = c(&quot;A&quot;, &quot;D&quot;, &quot;S&quot;), 
       x = c(2, 1, 0), 
       y = c(1, 0, 1)) %&gt;% 
  dagify(D ~ A + S,
         A ~ S,
         coords = .) %&gt;% 
  ggplot(aes(x = x, y = y, xend = xend, yend = yend)) +
  geom_dag_node(color = red, alpha = 0.5) +
  geom_dag_text(aes(label = name), color = blue) +
  geom_dag_edges(edge_color = blue) +
  theme_void()</code></pre>
<div class="figure">
<img src="/post/chapter5_files/figure-html/5M4%20print%20part%202-1.png" alt="*Directed acyclic graph for question 5M4*" width="672" />
<p class="caption">
(#fig:5M4 print part 2)<em>Directed acyclic graph for question 5M4</em>
</p>
</div>
<p>And check the implied conditional independencies.</p>
<pre class="r"><code>dagitty(&#39;dag{A -&gt; S
             A -&gt; D &lt;- S}&#39;) %&gt;% 
  impliedConditionalIndependencies() %&gt;% 
  capture.output() </code></pre>
<pre><code>## character(0)</code></pre>
<p>I have tried to catch the output but only get an empty character vector, which means that there are no conditional independencies. Let’s check this assumption with <code>cor()</code>.</p>
<pre class="r"><code>divorce_std %&gt;% 
  select(D, A, S) %&gt;% 
  as.matrix() %&gt;% 
  cor()</code></pre>
<pre><code>##            D          A          S
## D  1.0000000 -0.5972392  0.3451758
## A -0.5972392  1.0000000 -0.2480568
## S  0.3451758 -0.2480568  1.0000000</code></pre>
<p>Well A and S are not totally correlated, but still we can see a dependency between each.</p>
<p>We can proceed to build a model following the categorical example in the chapter.</p>
<pre class="r"><code>m_divorce1 &lt;- alist(
  D ~ dnorm(mu, sigma), 
  mu &lt;- a[S] + bA*A , 
  a[S] ~ dnorm(0, 0.5),
  bA ~ dnorm(0 ,0.5),
  sigma ~ dexp(1)) %&gt;% 
  quap(., data = divorce_std)</code></pre>
<p>Let’s extract some samples from the posterior and calculate the difference between southern and non-southern states.</p>
<pre class="r"><code>post_samples &lt;- extract.samples(m_divorce1) %&gt;% 
  as_tibble() %&gt;% 
  mutate(south_diff = a[,2] - a[,1])

post_samples %&gt;% 
  precis() %&gt;% 
  as_tibble(rownames = &quot;estimate&quot;) %&gt;% 
  filter(estimate != &quot;sigma&quot;) %&gt;% 
  rename(lower_pi = &#39;5.5%&#39;, upper_pi = &#39;94.5%&#39;)  %&gt;%  
  ggplot() +
  geom_vline(xintercept = 0, colour = &quot;grey40&quot;)  +
  geom_pointrange(aes(x = mean, xmin = lower_pi, xmax = upper_pi, 
                      y = fct_reorder(estimate, desc(estimate)), 
                      colour = estimate)) +
  scale_colour_discrete(name = &quot;Predictor&quot;, 
                        labels = c(&quot;Southern State&quot;, &quot;Non-Southern State&quot;,  
                                   &quot;Age at Marriage&quot;, &quot;Non-Southern minus Southern&quot;), 
                        type = c(red, blue, yellow, lightblue)) +
  labs(x = &quot;Estimate&quot;, y = NULL) +
  theme_minimal() + 
  theme(panel.grid.major.y = element_blank())</code></pre>
<div class="figure">
<img src="/post/chapter5_files/figure-html/5M4%20print%20part%206-1.png" alt="*Coefficient plot for a multiple regression model with with divorce rate as outcome*" width="672" />
<p class="caption">
(#fig:5M4 print part 6)<em>Coefficient plot for a multiple regression model with with divorce rate as outcome</em>
</p>
</div>
<p>We can already see that southern states have a consistently lower divorce rate than nonsouthern states. As we already extracted some samples, let’s look at the posterior distribution for A and S. First get some point estimates (mean and pi) for these variables, which we can then highlight in the plot.</p>
<pre class="r"><code>post_samples_sum &lt;- post_samples %&gt;% 
  select(bA, south_diff) %&gt;% 
  pivot_longer(cols = everything(), names_to = &quot;parameter&quot;, values_to = &quot;estimate&quot;) %&gt;% 
  group_by(parameter) %&gt;% 
  nest() %&gt;% 
  mutate(estimate = map(data, &quot;estimate&quot;), 
         est_mean = map_dbl(estimate, mean), 
         est_pi = map(estimate, PI), 
         pi_low = map_dbl(est_pi, pluck(1)), 
         pi_high = map_dbl(est_pi, pluck(2))) %&gt;% 
  select(parameter, est_mean, pi_low, pi_high) </code></pre>
<p>Now we are ready to plot the distributions.</p>
<pre class="r"><code>post_samples %&gt;% 
  select(bA, south_diff) %&gt;% 
  pivot_longer(cols = everything(), names_to = &quot;parameter&quot;, values_to = &quot;estimate&quot;) %&gt;% 
  ggplot() +
  geom_vline(xintercept = 0, colour = &quot;grey20&quot;)  +
  geom_density(aes(x = estimate, fill = parameter), 
               colour = &quot;grey40&quot;, alpha = 0.8) +
  geom_pointrange(aes(est_mean, y = c(0.35, 0.35), 
                       xmin = pi_low, xmax = pi_high, 
                       group = parameter), 
                  colour = &quot;grey40&quot;, size = 0.6, 
             data = post_samples_sum) +
  scale_fill_manual(name = &quot;Parameter&quot;, values = c(red, yellow), 
                    labels = c(&quot;Age at Marriage&quot;, &quot;Non-Southern minus Southern State&quot;)) +
  scale_y_continuous(breaks = NULL) +
  labs(title = &quot;Outcome = Divorce rate&quot;, x = &quot;Estimate&quot;, y = NULL) +
  theme_minimal() +
  theme(legend.position = c(0.8, 0.8), 
        legend.background = element_rect(colour = &quot;grey20&quot;))</code></pre>
<p><img src="/post/chapter5_files/figure-html/5M4%20print%20part%208-1.png" width="672" /></p>
<p>I think this plot is a nice way to end. Just to some this chapter up: I have learned a lot of powerful ways to get closer to deducing causal relationships, something that I wanted to do since reading <em>The book of why</em> by Dana Mackenzie and Juda Pearl. However, some concepts like confounders or such are still a bit unclear and I hope that this will be resolved throughout the next chapters.</p>
<hr />
<pre class="r"><code>sessionInfo()</code></pre>
<pre><code>## R version 4.0.3 (2020-10-10)
## Platform: x86_64-pc-linux-gnu (64-bit)
## Running under: Linux Mint 20.1
## 
## Matrix products: default
## BLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0
## LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0
## 
## locale:
##  [1] LC_CTYPE=de_DE.UTF-8       LC_NUMERIC=C              
##  [3] LC_TIME=de_DE.UTF-8        LC_COLLATE=de_DE.UTF-8    
##  [5] LC_MONETARY=de_DE.UTF-8    LC_MESSAGES=de_DE.UTF-8   
##  [7] LC_PAPER=de_DE.UTF-8       LC_NAME=C                 
##  [9] LC_ADDRESS=C               LC_TELEPHONE=C            
## [11] LC_MEASUREMENT=de_DE.UTF-8 LC_IDENTIFICATION=C       
## 
## attached base packages:
## [1] parallel  stats     graphics  grDevices utils     datasets  methods  
## [8] base     
## 
## other attached packages:
##  [1] dagitty_0.3-1        ggdag_0.2.3          rethinking_2.13     
##  [4] rstan_2.21.2         StanHeaders_2.21.0-7 forcats_0.5.0       
##  [7] stringr_1.4.0        dplyr_1.0.3          purrr_0.3.4         
## [10] readr_1.4.0          tidyr_1.1.2          tibble_3.0.5        
## [13] ggplot2_3.3.3        tidyverse_1.3.0     
## 
## loaded via a namespace (and not attached):
##  [1] matrixStats_0.57.0 fs_1.5.0           lubridate_1.7.9.2  httr_1.4.2        
##  [5] tools_4.0.3        backports_1.2.1    R6_2.5.0           DBI_1.1.1         
##  [9] colorspace_2.0-0   withr_2.4.1        tidyselect_1.1.0   gridExtra_2.3     
## [13] prettyunits_1.1.1  processx_3.4.5     curl_4.3           compiler_4.0.3    
## [17] cli_2.2.0          rvest_0.3.6        xml2_1.3.2         labeling_0.4.2    
## [21] bookdown_0.21      scales_1.1.1       mvtnorm_1.1-1      callr_3.5.1       
## [25] digest_0.6.27      rmarkdown_2.6      pkgconfig_2.0.3    htmltools_0.5.1.1 
## [29] dbplyr_2.0.0       highr_0.8          rlang_0.4.10       readxl_1.3.1      
## [33] rstudioapi_0.13    shape_1.4.5        generics_0.1.0     farver_2.0.3      
## [37] jsonlite_1.7.2     inline_0.3.17      magrittr_2.0.1     loo_2.4.1         
## [41] Rcpp_1.0.6         munsell_0.5.0      fansi_0.4.2        viridis_0.5.1     
## [45] lifecycle_0.2.0    stringi_1.5.3      yaml_2.2.1         ggraph_2.0.4      
## [49] MASS_7.3-53        pkgbuild_1.2.0     grid_4.0.3         ggrepel_0.9.1     
## [53] crayon_1.3.4       lattice_0.20-41    graphlayouts_0.7.1 haven_2.3.1       
## [57] hms_1.0.0          knitr_1.30         ps_1.5.0           pillar_1.4.7      
## [61] igraph_1.2.6       boot_1.3-25        codetools_0.2-18   stats4_4.0.3      
## [65] reprex_1.0.0       glue_1.4.2         evaluate_0.14      blogdown_1.1      
## [69] V8_3.4.0           RcppParallel_5.0.2 modelr_0.1.8       tweenr_1.0.1      
## [73] vctrs_0.3.6        cellranger_1.1.0   polyclip_1.10-0    gtable_0.3.0      
## [77] assertthat_0.2.1   ggforce_0.3.2      xfun_0.20          broom_0.7.3       
## [81] tidygraph_1.2.0    coda_0.19-4        viridisLite_0.3.0  ellipsis_0.3.1</code></pre>
</div>
</div>
